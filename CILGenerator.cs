/* Date: 04-May-2018
* Authors:
*          A01374526 Jos√© Karlo Hurtado Corona
*          A01373890 Gabriela Aguilar Lugo
*          A01375996 Alan Joseph Salazar Romero
*
*          To see special comments regarding this software please refer to the README included.
*/


using System;
using System.Text;
using System.Collections.Generic;
using System.Collections;
using System.IO;
using System.Text.RegularExpressions;

namespace DeepLingo {

    class CILGenerator {

        SymbolTable table;
        FuncTable  functionsT;

        IDictionary<string, int> haScoolReturn = new SortedDictionary<string, int>();        

        int labelCounter  =  0;
        string loopExit   = "";
        int ifcounter     =  0; 
        string amimain    = "";
        string actualFun  = "";
        int mymaxstackval = 200;
        int mycoolReturn  = 0;
        string lastIF     = "";
        string elsifexit = "";
 
        string GenerateLabel() {
            return String.Format("${0:000000}", labelCounter++);
        }    

        string myType = "int32"; 

        public CILGenerator(SymbolTable table, FuncTable  functionsT ) {
            this.table      = table;
            this.functionsT = functionsT;
        }

        //<Program>//
        public string Visit(Program node)
        {
            return "// Code generated by the DeepLingo compiler.\n\n" 
                + ".assembly 'deepLingo' {}\n\n"
                + ".assembly extern 'deeplingolib' {}\n\n"
                + ".class public 'DeepLingoProgram' extends " 
                + "['mscorlib']'System'.'Object' {\n\n" 
                + Visit((dynamic) node[0])
                + "}\n";
        }

        //<def>//
        public string Visit(Def node) {
            return VisitChildren(node,1);
        }

        //<vardef>//
        public string Visit(VarDef node,int i) 
        {
            //Visit((dynamic) node[0], i);
            // The code for the local variable declarations is 
            // generated directly from the symbol table, not from 
            // the AST nodes.
            //GLOBALS
            var sb = new StringBuilder();
            foreach (var entry in table) {
                sb.Append(String.Format(
                              "\t\t.field public static {0} '{1}'\n",                              
                              myType,
                              entry.Key)
                          );
            }
            return sb.ToString();
        }

        //<id>//
        public string Visit(Identifier node, int i)
        {
            return node.AnchorToken.Lexeme;
        }

        //<funDef>//
        public string Visit(FunDef node, int myint)
        {
            var currentFunc = Visit((dynamic) node[0], 1);
            var sb = new StringBuilder();
            actualFun = currentFunc;
            if (currentFunc != "main")
            {
                amimain = "no";
                sb.Append("\t.method public static int32 '"+currentFunc+"' (");
            }
            else if (currentFunc == "main")
            {
                amimain = "yes";
                sb.Append("\t.method public static void 'start' (");                
            }
            
            var functionAttr      = functionsT[currentFunc];
            
            var functionContainer = functionAttr.refToFunc;
            var mypartFunct       = functionContainer.ParticularFunction; 
            var mykeys            = mypartFunct.getkeys();
            IDictionary<int, string> paramposlist = new SortedDictionary<int, string>();  

            foreach (var elitemo in mykeys)
            {
                var sb2 = new StringBuilder();                
                var item = mypartFunct[elitemo];

                if (item.paramPos > -1)
                {
                    if (item.paramPos == 0)
                    {
                        sb2.Append(String.Format("int32 '{0}'", elitemo));
                    }
                    else
                    {
                        sb2.Append(String.Format(", int32 '{0}'", elitemo));
                    }
                }
                if (!paramposlist.ContainsKey(item.paramPos))
                {
                    paramposlist.Add(item.paramPos,sb2.ToString());                    
                }
            }

            foreach (var xOne in paramposlist)
            {
                sb.Append(xOne.Value);
            }

            sb.Append(")\n\t{\n");
            if (currentFunc == "main" )
            {
                sb.Append("\t\t.entrypoint\n"); 
                sb.Append("\t\t.maxstack "+mymaxstackval*5+"\n");                             
            }
            else
            {
                sb.Append("\t\t.maxstack "+mymaxstackval*5+"\n");                             
            }

            foreach (var elitemo in mykeys)
            {
                var item = mypartFunct[elitemo];                
                if (item.paramPos <= -1)
                {
                    sb.Append(String.Format(
                              "\t\t.locals init ({0} '{1}')\n",                              
                              myType,
                              elitemo)
                    );
                }
            }
            sb.Append("\t\n" + Visit((dynamic) node[3]) + "\n");
            
            if (currentFunc == "main" || mycoolReturn != 1)
            {
                if (mycoolReturn != 1)
                {
                    sb.Append( "\t\tldc.i4.0\n");                    
                }
                if (amimain.Equals("yes") && mycoolReturn != 1)
                {     
                    sb.Append("\t\tcall void class ['mscorlib']'System'.'Environment'::'Exit'(int32)\n" );
                }
                if (mycoolReturn != 1)
                {
                    sb.Append("\t\tret\n");
                }
            }
             sb.Append("\t}\n");
             mycoolReturn = 0;
             amimain = "no";
             actualFun = "";
             return sb.ToString();
        }

        //<funcall>//
        public string Visit(FunCall node)
        {
            String currentFunc = node.AnchorToken.Lexeme;
            var sb = new StringBuilder();
            var functionAttr = functionsT[currentFunc];

            sb.Append(VisitChildren(node));  

            if (functionAttr.p_or_u.Equals("p") )
            {
                sb.Append("\t\tcall int32 class  ['deeplingolib']'DeepLingo'.'Utils'::'" + char.ToUpper(currentFunc[0]) + currentFunc.Substring(1) + "'" );
            }
            else
            {
                sb.Append("\t\tcall int32 class 'DeepLingoProgram'::'" + currentFunc + "'" );
            }
            sb.Append("(");

            if (functionAttr.arity>0)
            {
                for (int ue = 0; ue < functionAttr.arity-1; ue++)
                {
                    sb.Append("int32, ");   
                }
                sb.Append("int32");
            }
            sb.Append(")\n");


            if (functionAttr.p_or_u.Equals("p"))
            {
               if (currentFunc.Equals("printi")||currentFunc.Equals("printc")||currentFunc.Equals("prints")||currentFunc.Equals("println")||currentFunc.Equals("add")||currentFunc.Equals("set"))
               {
                    sb.Append("\t\tpop\n");                   
               }
            }else
            {
                if (!haScoolReturn.ContainsKey(currentFunc))
                {
                    sb.Append("\t\tpop\n");
                }
            }


            return sb.ToString();
        }

        //<Loop>//
        public string Visit(Loop node)
        {
            var myLabel  = GenerateLabel();
            var oldELoop = loopExit;
            loopExit     = GenerateLabel(); 
            var result   = myLabel + ":\n"
            + Visit((dynamic) node[0]) 
            + "\t\tbr " + myLabel + "\n"
            + loopExit + ":\n";
            loopExit = oldELoop;
            return result;
        }

        //<vardef-list>//
        public string Visit(VarDefList node ) 
        {
            return "";
        }     

        //<assign>//
        public string Visit(Assign node ) {
            var onething          =  node.AnchorToken.Lexeme;
            var functionAttr      = functionsT[actualFun];
            //Console.WriteLine(actualFun);
            var functionContainer = functionAttr.refToFunc;
            var mypartFunct       = functionContainer.ParticularFunction; 
            var mykeys            = mypartFunct.getkeys();

            if(mykeys.Contains(onething))
            {
                var actfuncdata = mypartFunct[onething];

                if (actfuncdata.locale.Equals("param"))
                {
                    return Visit((dynamic) node[0]) 
                    + "\t\tstarg '" 
                    + onething 
                    + "'\n";
                }
                return Visit((dynamic) node[0]) 
                    + "\t\tstloc '" 
                    + onething 
                    + "'\n";
            }

            return Visit((dynamic) node[0]) 
                + "\t\tstsfld int32 DeepLingoProgram::'" 
                + onething 
                + "'\n";  
        }

        //<increase>//
        public string Visit(Increase node )
        {
            var sb = new StringBuilder();
            sb.Append( "\t\tldloc '" + node.AnchorToken.Lexeme + "'\n");
            sb.Append( "\t\tldc.i4.1\n");
            sb.Append( "\t\tadd.ovf\n");
            sb.Append( "\t\tstloc '" + node.AnchorToken.Lexeme + "'\n");
            return sb.ToString();
        }

        //<decrease>//
        public string Visit(Decrease node ) 
        {
            var sb = new StringBuilder();
            sb.Append( "\t\tldloc '" + node.AnchorToken.Lexeme + "'\n");
            sb.Append( "\t\tldc.i4.1\n");
            sb.Append( "\t\tsub.ovf\n");
            sb.Append( "\t\tstloc '" + node.AnchorToken.Lexeme + "'\n");
            return sb.ToString();
        }

        //ARRAYS//
        public string Visit(ArrayNode node)
        {
            int counterone = 0;
            var sb = new StringBuilder();
            ArrayList theInts = new ArrayList();

            foreach (var n in node) 
            {
                theInts.Add(Visit((dynamic) n));
            }

            foreach (var x in theInts)
            {
                counterone++;
            }

            sb.Append("\t\tldc.i4 "+ 0 +"\n");
            sb.Append(String.Format("\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'New'(int32)\n\n"));
            for (int i = 0; i < counterone; i++)
            {
                sb.Append("\t\tdup\n");                
            }
            foreach (var x in theInts)
            {
                sb.Append(x);
                sb.Append(String.Format("\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Add'(int32,int32)\n\n"));
                sb.Append("\t\tpop\n");
            }

            return sb.ToString(); 
        }

        //<id-List>
        public string Visit(IdList node) 
        {
            return "";
        }

        //<id>//
        public string Visit(Identifier node)
        {
            var onething          =  node.AnchorToken.Lexeme;
            var functionAttr      = functionsT[actualFun];
            var functionContainer = functionAttr.refToFunc;
            var mypartFunct       = functionContainer.ParticularFunction; 
            var mykeys            = mypartFunct.getkeys();
            if(mykeys.Contains(onething))
            {
                var actfuncdata = mypartFunct[onething];

                if (actfuncdata.locale.Equals("param"))
                {
                    return "\t\tldarg."
                    + actfuncdata.paramPos
                    + "\n";
                }
                return "\t\tldloc '"
                    + onething
                    + "'\n";
            }

            return "\t\tldsfld int32 DeepLingoProgram::'" 
                + onething 
                + "'\n";  
        }

        //<Break>//
        public string Visit(Break node )
        {
            return "\t\tbr " + loopExit + "\n";
        }

        //<Return>//
        public string Visit(Return node)
        {
            var sb = new StringBuilder();
            sb.Append(VisitChildren(node)); 
            if (amimain.Equals("yes"))
            {                
                sb.Append("\t\tldc.i4.0\n");
                sb.Append("\t\tcall void class ['mscorlib']'System'.'Environment'::'Exit'(int32)\n" );
            }
            sb.Append("\t\tret\n");
            mycoolReturn = 1;
            if (!haScoolReturn.ContainsKey(actualFun))
            {
                haScoolReturn.Add(actualFun,1);
            }
            return sb.ToString();
        }

        //<stmt-list>//
        public string Visit(StmtList node)
        {
            if (CountChildren(node)>0)
            {
                return VisitChildren(node);
            }
            return "";
        }

        //<expr-list>//
        public string Visit(ExpressionList node)
        {
            if (CountChildren(node)>0)
            {
                return VisitChildren(node);
            }
            return "";
        }

        //<expr><-<expr-or>//
        public string Visit(Or node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4 42\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\tbeq '" + myLabel + "'\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\tbeq '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4.0\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString();    
        }

        //<expr><-<expr-and>//
        public string Visit(And node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4.0\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\tbne.un '" + myLabel + "'\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\tbne.un '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString();    
        }

        //<expr><-<equal-to>//
        public string Visit(EqualTo node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4.0\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tbne.un '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString(); 
        }

        //<expr><-<not-equal-to>//
        public string Visit(NotEqualTo node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4.0\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tbeq '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString(); 
        }

        //<expr-rel><--<LessThan>//
        public string Visit(LessThan node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4 42\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tblt '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4.0\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString(); 
        }
                
        //<expr-rel><--<LessThanorequal>//
        public string Visit(LessThanOrEqual node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4 42\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tble '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4.0\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString(); 
        }

        //<expr-rel><--<GreaterThan>//
        public string Visit(GreaterThan node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4 42\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tbgt '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4.0\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString(); 
        }
                
        //<expr-rel><--<GreaterThanorequal>//
        public string Visit(GreaterThanOrEqual node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4 42\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tbge '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4.0\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString(); 
        }

        //<expr-rel><--<ExprAdd>//
        public string Visit(Add node )
        {
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tadd.ovf\n");
            return sb.ToString(); 
        }

        //<expr-rel><--<ExprRes>//
        public string Visit(Res node )
        {
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tsub.ovf\n");
            return sb.ToString(); 
        }

        //<expr-mul><--<Mul>//
        public string Visit(Multiply node )
        {
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tmul.ovf\n");
            return sb.ToString(); 
        }

        //<expr-mul><--<Rem>//
        public string Visit(Remainder node )
        {
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\trem\n");
            return sb.ToString(); 
        }

        //<expr-mul><--<Div>//
        public string Visit(Div node )
        {
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic) node[0]) + "\n");
            sb.Append(Visit((dynamic) node[1]) + "\n");
            sb.Append("\t\tdiv\n");
            return sb.ToString(); 
        }

        //<expr-unary><--<NOT>//
        public string Visit(Not node )
        {
            var sb = new StringBuilder();
            var myLabel = GenerateLabel();
            sb.Append("\t\tldc.i4.0\n");
            sb.Append(Visit((dynamic) node[0]) + "\n");            
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\tbeq '" + myLabel + "'\n");
            sb.Append("\t\tpop\n");
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\t'" + myLabel + "':\n");
            return sb.ToString(); 
        }

        public ArrayList getthechar(string stringwithchar)
        {
            ArrayList thereturn = new ArrayList();

            Regex regex = new Regex(@"([^'\n\\]|\\n|\\r|\\t|\\\\|\\'|\\""|\\u[0-9a-fA-F]{6})", RegexOptions.Multiline);
            foreach (Match m in regex.Matches(stringwithchar))
            {
                if (m.Groups[1].Success)
                {
                    thereturn.Add(m.Value);
                }
            }
            return thereturn;
        }

        //<expr-primary><--<str>//
        public string Visit(StringLiteral node )
        {
            int counterone = 0;
            var sb = new StringBuilder();
            string stringstring = node.AnchorToken.Lexeme;
            stringstring = stringstring.Substring(1);
            var thisOneArray = stringstring.ToCharArray();
            Array.Reverse(thisOneArray);
            stringstring = new string(thisOneArray);
            stringstring = stringstring.Substring(1);
            thisOneArray = stringstring.ToCharArray();
            Array.Reverse(thisOneArray);
            stringstring = new string(thisOneArray);

            ArrayList nuChar = getthechar(stringstring);

            foreach (var x in nuChar)
            {
                counterone++;
            }

            sb.Append("\t\tldc.i4 "+ 0 +"\n");
            sb.Append(String.Format("\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'New'(int32)\n\n"));
            for (int i = 0; i < counterone; i++)
            {
                sb.Append("\t\tdup\n");                
            }
            foreach (string x in nuChar)
            {
                int thisuniquevalue = getmemychar(x,0);
                sb.Append("\t\tldc.i4 "+thisuniquevalue+"\n");
                sb.Append(String.Format("\t\tcall int32 class ['deeplingolib']'DeepLingo'.'Utils'::'Add'(int32,int32)\n\n"));
                sb.Append("\t\tpop\n");
            }

            return sb.ToString(); 
        }

        private static IEnumerable<int> AsCodePoints(string str) {
            for(int i = 0; i < str.Length; i++) {
                yield return char.ConvertToUtf32(str, i);
                if (char.IsHighSurrogate(str, i)) {
                    i++;
                }
            }
        }

        public int getmemychar(string charsting,int myintm8)
        {
            var charVal = 0;
            if (charsting.Contains(@"\u"))
            {
                charsting  = charsting.Replace(@"\u", "");
                charsting  = charsting.Replace("'", "");
                charVal    = Convert.ToInt32(charsting, 16);

            }
            else
            {
                string charChar = charsting.Trim();

                if(myintm8 == 1)
                {
                    charChar = charChar.Substring(1);
                    var thisOneArray = charChar.ToCharArray();
                    Array.Reverse(thisOneArray);
                    charChar = new string(thisOneArray);
                    charChar = charChar.Substring(1);
                    thisOneArray = charChar.ToCharArray();
                    Array.Reverse(thisOneArray);
                    charChar = new string(thisOneArray);
                }

                if (charChar.Equals(@"\n"))
                {
                    charVal = 10;                    
                }
                else if (charChar.Equals(@"\r"))
                {
                    charVal = 13;       
                }
                else if (charChar.Equals(@"\t"))
                { 
                    charVal = 9;
                }
                else if (charChar.Equals(@"\\"))
                {
                    charVal = 92;
                }
                else if (charChar.Equals(@"\'"))
                {
                    charVal = 39;
                }
                else if (charChar.Equals(@"\"""))
                {
                    charVal = 34;
                }
                else if (charChar.Equals(@" "))
                {
                    charVal = 32;
                }
                else
                {
                    var smchr =  AsCodePoints(charChar);
                    foreach (var x in smchr)
                    {
                        charVal = x;
                    }   
                }
            }
            if (charVal == 0)
            {
                return 32;
            }
            return charVal;
        }

        //<expr-primary><--<char>//
        public string Visit(CharLiteral node )
        {
            var charVal = 0;
            string charsting = node.AnchorToken.Lexeme;
            charVal = getmemychar(charsting,1);
            var sb = new StringBuilder();
            sb.Append("\t\tldc.i4 "+charVal+"\n");
            return sb.ToString(); 
        }
        
        //<expr-primary><--<int>//
        public string Visit(IntLiteral node )
        {
            var sb = new StringBuilder();
            var thisInt = node.AnchorToken.Lexeme;
            if (thisInt[0].Equals('+')||thisInt[0].Equals('-'))
            {
                var nosignint = thisInt.Substring(1);
                if (thisInt[0].Equals('-'))
                {
                    sb.Append("\t\tldc.i4.0\n");
                    sb.Append("\t\tldc.i4 " + Int32.Parse(nosignint)+ "\n");
                    sb.Append("\t\tsub.ovf\n");   
                }
                else
                {
                    sb.Append("\t\tldc.i4 " + Int32.Parse(nosignint)+ "\n");
                }
            }
            else
            {
                sb.Append("\t\tldc.i4 " + Int32.Parse(thisInt)+ "\n");
            }
            return sb.ToString(); 
        }

        //<if>//
        public string Visit(If node )
        { 
            var sb = new StringBuilder();
            string somestr = Visit((dynamic) node[0]);
            sb.Append(somestr);
           // Console.WriteLine(somestr);
            ifcounter++;
            sb.Append("\t\tldc.i4 42\n");
            var myLabel  = GenerateLabel();
            sb.Append("\t\tbne.un  " + myLabel+ "\n");
            sb.Append(Visit((dynamic) node[1]));
            lastIF = GenerateLabel();
            var mylastIF = lastIF;   
            var elsiftext = VisitElsif(node);

            if (!elsiftext.Equals(""))
            {
                sb.Append("\t\tbr '" + mylastIF + "'\n");
                sb.Append("\t\t'" + myLabel + "':\n");            
            }
            sb.Append(elsiftext);
            
            var elsetext = VisitElse(node);
            if(elsetext.Equals("")&&elsiftext.Equals(""))
            {
                sb.Append("\t\t'" + myLabel + "':\n");  
            }
            else if (!elsetext.Equals("")&&elsiftext.Equals(""))
            {
                sb.Append("\t\tbr '" + mylastIF + "'\n");
                sb.Append("\t\t'" + myLabel + "':\n");      
            }
            else
            {
                lastIF = "";                                
            }

            
            sb.Append(elsetext);
            sb.Append("\t\t'" + mylastIF + "':\n");                        
            ifcounter = 0;          
            return sb.ToString(); 
        }

        //<elseif>//
        public string Visit(ElseIfList node )
        {
            elsifexit = lastIF;
            if ( 0 < CountChildren(node))
            {
                return VisitChildren(node);
            }
            return "";
        }

        //<elseif>//
        public string Visit(ElseIf node )
        {
            var thisexit = elsifexit;
            var tempLabel  = GenerateLabel();
            var sb = new StringBuilder();
            sb.Append(Visit((dynamic) node[0]));
            sb.Append("\t\tldc.i4 42\n");
            sb.Append("\t\tbne.un " + tempLabel+ "\n");
            sb.Append(VisitAllButOne(node));
            sb.Append("\t\tbr '" + thisexit + "'\n");  
            sb.Append("\t\t'" + tempLabel + "':\n");  
            thisexit = ""; 
            return sb.ToString(); 
        }

        //<else>//
        public string Visit(Else node )
        {
            var sb = new StringBuilder();
            
            if (0<CountChildren(node))
            {
                sb.Append(Visit((dynamic) node[0]));               
            }
            return sb.ToString(); 
        }

#region independentFuncs
       
        string VisitChildren(Node node) 
        {
            var sb = new StringBuilder();
            foreach (var n in node) 
            {
                sb.Append(Visit((dynamic) n));
            }
            return sb.ToString();
        }

        string VisitAllButOne(Node node) 
        {
            var sb = new StringBuilder();
            var mycounter = 0;
            foreach (var n in node) 
            {
                if (mycounter != 0)
                {
                    sb.Append(Visit((dynamic) n));
                    ifcounter++;
                }
                else
                {
                    mycounter = 1;
                }
            }
            return sb.ToString();
        }

        string VisitAllButTwo(Node node) 
        {
            var sb = new StringBuilder();
            var mycounter = 0;
            foreach (var n in node) 
            {
                if (mycounter > 1)
                {
                    sb.Append(Visit((dynamic) n));
                }
                else 
                {
                    mycounter++;
                }
            }
            return sb.ToString();
        }

        string VisitElsif(Node node) 
        {
            var sb = new StringBuilder();
            var mycounter = 0;
            foreach (var n in node) 
            {
                if (mycounter == 2)
                {
                    sb.Append(Visit((dynamic) n));
                    mycounter++;
                }
                else 
                {
                    mycounter++;
                }
            }
            return sb.ToString();
        }

        string VisitElse(Node node) 
        {
            var sb = new StringBuilder();
            var mycounter = 0;
            foreach (var n in node) 
            {
                if (mycounter == 3)
                {
                    sb.Append(Visit((dynamic) n));
                    mycounter++;
                }
                else 
                {
                    mycounter++;
                }
            }
            return sb.ToString();
        }

        string VisitChildren(Node node, int i) 
        {
            var sb = new StringBuilder();
            foreach (var n in node) 
            {
                sb.Append(Visit((dynamic) n, i));               
            }
            return sb.ToString();
        }

        int CountChildren(Node node) 
        {
            int i = 0;
            foreach (var n in node) 
            {
                i++;
            }
            return i;
        }
#endregion
    }
}
